# eloquent js

## 7. Проект Робот

### Задача

В деревне Луговое всего 11 домов, между которыми проложено 14 тропинок.

```js
const roads = [
  "Alice's House-Bob's House",   "Alice's House-Cabin",
  "Alice's House-Post Office",   "Bob's House-Town Hall",
  "Daria's House-Ernie's House", "Daria's House-Town Hall",
  "Ernie's House-Grete's House", "Grete's House-Farm",
  "Grete's House-Shop",          "Marketplace-Farm",
  "Marketplace-Post Office",     "Marketplace-Shop",
  "Marketplace-Town Hall",       "Shop-Town Hall"
];
```

Робот почтальон перемещается от дома к дому, забирая или оставляю посылки.

![village](07_00.png)

**Задача** найти кротчайший путь, чтобы собрать и доставить посылки одновременно.

### Граф

Деревня это граф, где дома - вершины, а тропинки - ребра.

<img src="07_01.png">

Список смежностей графа хранится в объекте, т.е. в словаре массивов или структуре данных `roadGraph`:

```js
const roadGraph = {
    "Alice's House": ["Bob's House", 'Cabin', 'Post Office'],
    "Bob's House": ["Alice's House", 'Town Hall'],
}
```

где, для каждой вершины указаны ее смежные вершины.

### Способы решения

Для решения задачи можно использовать разные способы:

1. Случайный поиск
2. Поиск по заранее продуманному маршруту
3. Поиск на основе алгоритмов
    - [BFS](https://en.wikipedia.org/wiki/Breadth-first_search)
    - [DFS](https://en.wikipedia.org/wiki/Depth-first_search)
    - [A*](https://en.wikipedia.org/wiki/A*_search_algorithm).

### Состояния

ООП деревни построено не по принципу "каждый предмет это объект", но по принципу состояний. Т.е. есть один класс `VillageState`, на основе которого строятся объекты содержащие состояние деревни в конкретный момент времени, как кадры анимации или кинопленки.
Конструктор класса состояния принимает два аргумента: текущее положение робота и коллекцию недоставленных посылок.

### Посылки

Посылки хранятся в объекта `parcels`:

```js
const parcels = {
    {place: "Daria's House", address: "Post Office"},
    {place: "Alice's House", address: "Bob's House"},
}
```

где, для каждой посылки указано ее положение и место назначения.

Список посылок формируется автоматически случайным образом,

### Движение

У состояния есть метод `move` который принимает в качестве аргумента место назначения, т.е. дом к которому роботу нужно двигаться и возвращает новое состояние деревни, т.е. новый объект состояния деревни.

Под капотом метод `move` выполняет сразу несколько действий:

1. Проверяет есть ли ребро от текущего положения робота к месту назначения в списке смежностей `roadGraph`.
    - если смежных вершин нет, то возвращает текущее состояние деревни.
    - если есть ребра, то:
        - пробегаемся по списку посылок:
            - если текущее место конкретной посылки не равно месту назначения, то возвращаем неизменную посылку.
            - иначе, меняем текущее местоположение конкретной посылки на место назначения аргумента move()
        - удаляем из списка посылок все чье текущее местоположение равно месту назначения, т.е. доставленные
        - создает новое состояние деревни с новым положением робота.
2. Возвращает новое состояние деревни, со следующими аргументами конструктора:
    - текущее положение робота - место назначения аргумента move()
    - список посылок - это измененный, т.е. отфильтрованный список посылок из прошлого состояния

Для выбора решения куда двигаться далее (аргумент метода move) используется робот.

### Роботы

Робот это функция, возвращающая объект вида `{"direction": "Alice's House"}`.

Можно написать собственного робота, но в книге перечислены 3:

1. randomRobot -Тупой робот без памяти, который рандомно выбирает маршрут и двигается пока не угадает все места назначения посылок.
2. routeRobot - Робот с памятью, который использует заранее переданный ему маршрут
3. goalOrientedRobot - Эффективный робот с памятью, который выбирает оптимальный маршрут

#### Тупой робот

Данный робот-функция принимает текущее состояние деревни
