# eloquent js

## 7. Проект Робот

Разбор оригинальной задачи ["Проект Робот"](https://eloquentjavascript.net/07_robot.html):

Есть деревня Луговое с 11 домами, между которыми проложено 14 троп:

![village](img/07_00.png)

Роботу почтальону необходимо используя имеющиеся тропы доставить все посылки адресатам, попутно забирая их в посещаемых домах.

### Данные

Дано 3 массива:

1. `roads` - тропы
    - `roadGraph` - список смежностей
2. `parcels` - посылки
    - случайный набор
    - фиксированный набор
3. `mailRoute` - маршрут обхода деревни
    - случайный набор
    - фиксированный набор

#### Тропы

14 тропинок описаны в массиве `roads` в формате *Начало маршрута*-*Конец Маршрута*:

```js
const roads = [
  "Alice's House-Bob's House",   "Alice's House-Cabin",
  "Alice's House-Post Office",   "Bob's House-Town Hall",
  "Daria's House-Ernie's House", "Daria's House-Town Hall",
  "Ernie's House-Grete's House", "Grete's House-Farm",
  "Grete's House-Shop",          "Marketplace-Farm",
  "Marketplace-Post Office",     "Marketplace-Shop",
  "Marketplace-Town Hall",       "Shop-Town Hall"
];
```

##### Граф

Из массива `roads` видно, что нет сквозной магистрали через всю деревню и каждой дом соединен тропами не со всеми соседями. Например из хижины (Cabin) можно попасть только в дом Алисы, но от нее уже можно попасть в дом Боба и на Почту. Чтобы понять можно ли попасть из любого дома в любой через промежуточные узлы (nodes) и что деревня например не разделена на две изолированные части, построим граф:

![village](img/07_01.png)

Из рисунка видно, что мы имеем связанный всенаправленный граф, где дома (nodes) соединены двунаправленными тропами (edges) и нет изолированных групп домов.

Для работы по построению маршрута между двумя произвольными домами неудобно использовать массив `roads`. Удобнее использовать другую структуру данных.

#### Список смежностей

Adjacency List - список смежностей широко используется в навигации, поэтому преобразуем массив `roads` используя функцию `buildGraph`:

```js
function buildGraph(edges) { // построитьГраф(маршруты)
  let graph = Object.create(null); // объект граф = чистый объект
  function addEdge(from, to) { // функция добавитьТочку(из, в)
    if (from in graph) { // если из уже в графе
      graph[from].push(to); // то добавить в массив поля со значение "из" объекта граф элемент со значением "в"
    } else { // иначе
      graph[from] = [to]; // создать массив с одним элементом со значением "в"  в поле объекта со значением "из" 
    }
  }
  for (let [from, to] of edges.map(r => r.split("-"))) { // пробежаться по картежу (из, в) разделенных по "-" в объекте маршруты   
    addEdge(from, to); // добавить с помощью функции построитьГраф точки из-в
    addEdge(to, from); // добавить с помощью функции построитьГраф точки в-из
  }
  return graph;
}
```

Функция вернет объект в виде списка смежностей графа:

```js
const roadGraph = {
  "Alice's House": [ "Bob's House", 'Cabin', 'Post Office' ],
  "Bob's House": [ "Alice's House", 'Town Hall' ],
  Cabin: [ "Alice's House" ],
  'Post Office': [ "Alice's House", 'Marketplace' ],
  'Town Hall': [ "Bob's House", "Daria's House", 'Marketplace', 'Shop' ],
  "Daria's House": [ "Ernie's House", 'Town Hall' ],
  "Ernie's House": [ "Daria's House", "Grete's House" ],
  "Grete's House": [ "Ernie's House", 'Farm', 'Shop' ],
  Farm: [ "Grete's House", 'Marketplace' ],
  Shop: [ "Grete's House", 'Marketplace', 'Town Hall' ],
  Marketplace: [ 'Farm', 'Post Office', 'Shop', 'Town Hall' ]
}
```

где, для каждой вершины указаны ее смежные.

#### Посылки

Массив посылок `parcels` имеет структуру:

```js
const parcels = {
    {place: "Daria's House", address: "Post Office"},
    {place: "Alice's House", address: "Bob's House"},
}
```

где, для каждой посылки указано ее место положение и назначения.

Массив посылок можно задать самому, либо случайным образом, с помощью кода:

```js
let parcels = []; // пустой массив посылок
for (let i = 0; i < parcelCount; i++) { // генерим нужное количество посылок в соответствии с переданным параметром parcelCount
// Вынимаем рандомно адресата из объекта графа roadGraph
let address = Object.keys(roadGraph)[Math.floor(Math.random() * Object.keys(roadGraph).length)];
let place; 
do { // вынимаем рандомно место нахождения посылки из объекта графа
    place = Object.keys(roadGraph)[Math.floor(Math.random() * Object.keys(roadGraph).length)];
} while (place == address); // есть место посылки и адресат совпадают, то повторяем цикл
parcels.push({place, address}); // если место и адресат разные, то добавляем посылку в массив
```

Данный код является статическим методом класса `VillageState.random()` см. "Состояние"

#### Маршрут

Не во все дома можно добраться напрямую. Обойти все места в деревне можно несколькими маршрутами, один из которых представлен в оригиналом проекте:

```js
const mailRoute = [
  "Alice's House", "Cabin", "Alice's House", "Bob's House",
  "Town Hall", "Daria's House", "Ernie's House",
  "Grete's House", "Shop", "Grete's House", "Farm",
  "Marketplace", "Post Office"
]
```

Данный маршрут является замкнутым, т.к. конечная точка "Post Office" ссылается на начальную "Alice's House", что видно из графа см. "Граф". Маршрут используется только одним роботом с маршрутной памятью [`mailRoute`](#робот-с-памятью). Остальные будут искать маршруты сами.

### Действия

В процессе обхода графа нужно выполнять следующие действия:

1. Фиксация состояний
    - посылок
    - робота
2. Совершение хода
    - загрузка
    - выгрузка

#### Фиксация состояний

Для хранения состояний робота и посылок будем использовать объекты класса `VillageState` в конкретный момент времени, как кадры анимации или кинопленки.
Конструктор класса состояния принимает два аргумента: текущее положение робота и массив недоставленных посылок.

```js
class VillageState {
  constructor(place, parcels) { // конструктор принимает (положение робота, коллекцию посылок)
    this.place = place; // положение робота
    this.parcels = parcels; // коллекция недоставленных посылок
  }
  static random(parcelCount = 5) {
  // код метода в разделе «Посылки»
  return new VillageState("Post Office", parcels);
 }
  move(destination) { // метод перемещения принимает положение робота
    // код метода в разделе «Обработка посылок»
      return new VillageState(destination, parcels); // возвращаем новое состояние деревни, где положение робота меняется на назначение
// из прошлого состояние и измененную коллекцию посылок
    }
  }
}
```

#### Ход

Выполняется методом `move()` объекта состояния класса созданного с помощью класса `VillageState`. Если нам известно место робота `this.place` и место назначения `destination`, то можно принять решение о каждой посылке:

```js
if (!roadGraph[this.place].includes(destination)) { // если текущее положение робота не имеет точки назначения, то
    return this; // вернуть текущее состояние деревни целиком
} else {
    let parcels = this.parcels.map(p => { // новый массив посылок, который мы вернем в новое состояние деревни, 
            // размапим текущий массив посылок, где рассматриваемая посылка это p
    if (p.place != this.place) return p; // если рассматриваемая посылка не равна текущему положению робота то вернем ее неизменной
    return {place: destination, address: p.address}; // иначе, мы меняем текущее место посылки на переданное в метод move(dest)
    }).filter(p => p.place != p.address); // удаляем доставленные посылки, т.е. оставляем только те, чье положение не равно назначению 
}
```

Ход, т.е. метод `move` выполняет сразу несколько действий:

1. Проверяет есть ли ребро от текущего положения робота к месту назначения в списке смежностей `roadGraph`.
    - если смежных вершин нет, то возвращает текущее состояние деревни.
    - если есть ребра, то:
        - пробегаемся по списку посылок:
            - если текущее место конкретной посылки не равно месту назначения, то возвращаем неизменную посылку.
            - иначе, меняем текущее местоположение конкретной посылки на место назначения аргумента move()
        - удаляем из списка посылок все чье текущее местоположение равно месту назначения, т.е. доставленные
        - создает новое состояние деревни с новым положением робота.
2. Возвращает новое состояние деревни, со следующими аргументами конструктора:
    - текущее положение робота - место назначения аргумента move()
    - список посылок - это измененный, т.е. отфильтрованный список посылок из прошлого состояния

Параметр `destination` передается в метод `move()` одним из 3-х роботов на выбор.

### Роботы

Роботом будем называть обычную функцию, которая принимает решение в какую сторону двигаться, она возвращает объект вида:

```js
{"direction": "Alice's House", "memory": []}
```

т.е. направление в сторону дома Алисы.

Ключ `memory` - это копия маршрута посылок `mailRoute` без проеденных вершин. Используется только двумя продвинутыми роботами.

Поиск направления движения можно осуществлять с помощью:

- Случайного выбора
- Заранее продуманного маршрута
- Различных алгоритмов: [BFS](https://en.wikipedia.org/wiki/Breadth-first_search) [DFS](https://en.wikipedia.org/wiki/Depth-first_search) [A*](https://en.wikipedia.org/wiki/A*_search_algorithm)

В соответствии с методами выбора направления следующего хода роботы могут быть:

1. Тупыми
2. С памятью
3. С умом

#### Тупой робот

Функция `randomRobot` - тупой робот без памяти `memory`, который рандомно выбирает маршрут и двигается пока не угадает все места назначения посылок.

```js
function randomRobot(state) {
  return {direction: randomPick(roadGraph[state.place])};
}
```

Функция randomPick(array) - возвращает случайное значение из переданного массива

```js
function randomPick(array) {
  let choice = Math.floor(Math.random() * array.length);
  return array[choice];
}
```

randomPick вынесена в вспомогательную функцию, чтобы реализовать принцип полиморфизма и показать, что данный код можно использовать повторно в других ситуациях.

#### Робот с памятью

`routeRobot` - Робот с памятью `memory`, который использует заранее спланированный маршрут [`mailRoute`](#маршрут).

```js
// робот принимает состояние и массив оставшегося маршрута
function routeRobot(state, memory) {
  if (memory.length == 0) { // есть длина маршрутный лист пустой
    memory = mailRoute; // то идем по второму кругу, т.е. обновляем заполняем память целым списком маршрутов
  }
  return {direction: memory[0], memory: memory.slice(1)}; // возвращаем первую вершину маршрута в качестве назначения и удаляем текущее положение
}
```

#### Робот с умом

Самый сложный робот, который использует для планирования своего маршрута обхода графа алгоритм BFS.

##### классический BFS

Breadth First Search (BFS) - алгоритм обхода графа в ширину, с помощью очереди FIFO.

При BFS происходит "поджигание" стартовой вершины, огнь от которой равномерно по распространятся вширь пока не поглотит все дерево графа.

В классическом алгоритме участвует 4 массива (списка):

- **queue** - очередь FIFO
- **visited** - список посещенных вершин
- **distances** - список расстояний (шагов) от стартовой вершины
- **parents** - список родителей (предшествующих) вершин

Используя классический BFS можно обойти весь граф и получить расстояние от стартовой вершины до любой другой вершины используюя следующий код:

```js
// 1. функция принимает список смежностей и стартовую вершину
const bfs = (graph, start) => {
    const queue = []; // пустой массив очереди
    const visited = {}; // пустой объект посещенных вершин
    const distances = {}; // пустой объект расстояний
    const parents = {}; // пустой объект родителей
    // 2. Для каждого узла графа выставляем начальные (пустые) значения во всех ключевых объектах
    for (let node in graph) {
        visited[node] = false; // вершина еще не посещена
        distances[node] = -1; // расстояние не известно
        parents[node] = null; // родителей еще нет
    }
    // 3. Инициализация очереди
    queue.push(start); // добавляем в очередь стартовый узел
    visited[start] = true; // помечаем данный узел посещенным
    distances[start] = 0; // выставляем нулевое расстояние, т.к. текущей узел у нас в месте старта
    // 4. цикл прохода по очереди
    while (queue.length > 0) { 
        const current_node = queue.shift(); // удаляем давно стоящий узел из очереди и кладем его в текущий узел 
        const neighbors = graph[current_node]; // получаем всех соседей текущего узла
        // 5. обходим всех соседей текущего узла
        for (const neighbor of neighbors) {
            if (!visited[neighbor]) { // при условии что соседа еще не посещали
                queue.push(neighbor); // помещаем текущего соседа в очередь
                visited[neighbor] = true; // помечаем соседа посещенным
                distances[neighbor] = distances[current_node] + 1; // увеличиваем расстояние соседа на 1
                parents[neighbor] = current_node; // устанавливаем текущему соседу родителем текущей узел
            }
        }
    }
    return { // 6. возвращаем результат
        // массив посещенных вершин (возвращаем только имена ключей объекта visited)
        visited_nodes: Object.keys(visited).filter(node => visited[node]),
        distances, // объект расстояний
        parents // объект родителей
    };
}
```

Логику функции bfs, можно разбить на 6 составных задач:

1. Аргументы
2. Инициализация массивов
3. Инициализация очереди
4. Основной цикл очереди
5. Вложенный цикл соседей
6. Возврат массивов

###### 1. Аргументы

Функция принимает два аргумента:

- **graph** - список смежностей
- **start** - стартовая вершина

###### 2. Инициализация массивов

При инициализации массивы имеют следующий вид:

```js
visited = { "Alice's House": false, "Bob's House": false, Cabin: false, "Post Office": false, "Town Hall": false, "Daria's House": false, "Ernie's House": false, "Grete's House": false, Farm: false, Shop: false, Marketplace: false};

distances = { "Alice's House": -1, "Bob's House": -1, Cabin: -1, "Post Office": -1, "Town Hall": -1, "Daria's House": -1, "Ernie's House": -1, "Grete's House": -1, Farm: -1, Shop: -1, Marketplace: -1};

parents = { "Alice's House": null, "Bob's House": null, Cabin: null, "Post Office": null, "Town Hall": null, "Daria's House": null, "Ernie's House": null, "Grete's House": null, Farm: null, Shop: null, Marketplace: null};
```

###### 3. Инициализация очереди

Инициализация очереди `queue` происходит со стартовой вершиной в качестве первого значения.

В массиве `visited` помечается стартовая вершина как посещенная `visited["Cabin"] = true;`

В массиве `distances` выставляется нулевое расстояние `distances["Cabin"] = 0;`

###### 4. Основной цикл очереди

Основной цикл выполняется до тех пор пока очередь не станет пустой.

Из очереди вытаскивается первая по списку вершина

Ищутся все ее смежные вершины (соседи) в списке смежностей `graph`

Далее список соседей передается вложенному циклу `for`

###### 5. Вложенный цикл соседей

Вложенный цикл проходит по всем соседям текущей вершины.

Если сосед не посещен, то он помечается как посещенный `visited[neighbor] = true;`

В очередь добавляется сосед `queue.push(neighbor);`

Расстояние соседа увеличивается на 1 `distances[neighbor] = distances[current_node] + 1;`

Сосед становится родителем текущей вершины `parents[neighbor] = current_node;`

###### 6. Возврат массивов

Наполненные массивы выглядят так:

```js
visited = {"Alice's House": true, "Bob's House": true, Cabin: true, "Post Office": true, "Town Hall": true, "Daria's House": true, "Ernie's House": true, "Grete's House": true, Farm: true, Shop: true, Marketplace: true};

distances = {"Alice's House": 1, "Bob's House": 2, Cabin: 0, "Post Office": 2, "Town Hall": 3, "Daria's House": 4, "Ernie's House": 5, "Grete's House": 5, Farm: 4, Shop: 4, Marketplace: 3};

parents = {"Alice's House": "Cabin", "Bob's House": "Alice's House", Cabin: null, "Post Office": "Alice's House", "Town Hall": "Bob's House", "Daria's House": "Town Hall", "Ernie's House": "Daria's House", "Grete's House": "Shop", Farm: "Marketplace", Shop: "Town Hall", Marketplace: "Post Office"};
```

Они возвращаются как результат функции

На основании полученных данных можно строить маршрут од стартовой точи и до желаемой

```js
function reconstructPath(parents, target) {
    const path = [];
    let current = target;
    // Двигаемся от целевой точки к началу через родителей
    while (current !== null) {
        path.push(current);
        current = parents[current];
    }
    // Разворачиваем путь, чтобы получить правильный порядок
    return path.reverse();
}
```
###### Книжный BFS

Алгоритм поиска маршрута книжного BFS отличается от классического набором данных, т.е. количеством и видом массивов: 

```js
function findRoute(graph, from, to) { // поиск маршрута (граф, откуда, куда)
  let work = [{at: from, route: []}]; // массив объектов, каждый содержит:
  // конечную вершина и маршрут от старта
  // тут work.at выступает как visited, work.route как parents и work.route.length как distances 
  for (let i = 0; i < work.length; i++) { // проверяется work как очередь на наличие необследованных вершин
    let {at, route} = work[i]; // деструктурируем вершину и маршрут
    for (let place of graph[at]) { // берем всех соседей из графа для текущей вершины work.at 
      if (place == to) return route.concat(place); // если сосед равен месту назначения то выходим из функции вернув искомый маршрут
      if (!work.some(w => w.at == place)) { // текущий сосед не в списке work.visited связанные с нею вершины
        work.push({at: place, route: route.concat(place)}); // добавляем в work.visited и маршрут до родителя + сосед
      }
    }
  }
}
```

Туту нет массивов `visited`, `distances` и `parents`, также нет классической очереди `queue`.

Все данные хранятся в массиве `work`. В нем находятся вершины, которые нужно обследовать следующими и их список маршрутов которые ведут к ним, так же он выполняет роль очереди. Это упрощает код, но усложняет понимание логики.

```js
function goalOrientedRobot({place, parcels}, route) {
  if (route.length == 0) {
    let parcel = parcels[0];
    if (parcel.place != place) {
      route = findRoute(roadGraph, place, parcel.place);
    } else {
      route = findRoute(roadGraph, place, parcel.address);
    }
  }
  return {direction: route[0], memory: route.slice(1)};
}
```

### Движок

Функции-роботы, возвращают только одно направление движения для конкретного состояния. Но, нужен механизм, автоматизирующий процесс запуска робота до полного опустошения массива посылок. Данным механизмом будет функция-движок `runRobot`:

```js
// функция принимает три аргумента: состояние, функцию-робот и память
function runRobot(state, robot, memory) {
  for (let turn = 0;; turn++) { // бесконечный цикл
    if (state.parcels.length == 0) { // если все посылки доставлены
      console.log(`Done in ${turn} turns`); // вывести количество ходов
      break; // выход
    }
    // присвоить возврат от функции-робота переменной action
    let action = robot(state, memory); // функция-робот принимает 2 аргумента: состояние и память
    state = state.move(action.direction); // сделать ход в направлении, которое вернула функция-робот
    memory = action.memory; // обновить локальную память функции движка значением, которое вернула функция-робот
    console.log(`Moved to ${action.direction}`); // вывести направление движения
  }
}
```

Движок как функция может принимать сразу 3 аргумента, но не обязательно все, это фишка языка JS, поэтому количество задаваемых параметров будет зависеть от запуска движка с конкретным роботом.

#### Запуск движка с тупым роботом

При запуске движка с тупым роботом укажем параметры - состояние и функцию-робота:

```js
runRobot(VillageState.random(), randomRobot);
```

Весь обход зависит от случайности, минимально зафиксированное мной количество ходов было 19, максимальное 173.

#### Запуск движка с роботом имеющим память

Движок запускается с 3 параметрами: состояние, функция-робот и маршрут.

```js
runRobot(VillageState.random(), routeRobot, mailRoute);
```

Обход всей деревни не зависит от случайности, но зависит от количества посылок и удаленности адресатов. В любом случае ходов не может быть более 25, что примерно составляет два круга по деревне. В худшем случае робот первый раз соберет, а второй доставит все посылки.

#### Запуск движка с умным роботом

